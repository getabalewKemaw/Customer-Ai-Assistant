üìê Refined Database Design for Supportly (MVP)
1. Users Collection
Purpose: Store user accounts (dual auth), roles, and profile info.
Schema (MVP fields):
‚Ä¢	_id: ObjectId ‚Üí primary key.
‚Ä¢	name: String (required) ‚Üí display name (manual or from Google).
‚Ä¢	email: String (required, unique, indexed) ‚Üí universal identifier.
‚Ä¢	password: String (optional) ‚Üí hashed, for email/password users only.
‚Ä¢	googleId: String (optional, unique) ‚Üí for Google users only.
‚Ä¢	authMethods: [String] (required) ‚Üí enum: ['email','google']. Tracks enabled login methods.
‚Ä¢	role: String (required, default: 'customer') ‚Üí enum: ['customer','agent','admin'].
‚Ä¢	profilePicture: String (optional) ‚Üí URL (Google or uploaded).
‚Ä¢	isVerified: Boolean (default: false) ‚Üí email verification status.
‚Ä¢	lastLogin: Date (optional) ‚Üí last active timestamp.
‚Ä¢	createdAt: Date (default: now)
‚Ä¢	updatedAt: Date (default: now)
üëâ Why these fields?
‚Ä¢	Covers both auth flows (Google + email).
‚Ä¢	Roles give us RBAC immediately.
‚Ä¢	Profile + verification keep it professional.
‚Ä¢	Everything else (preferences, company, etc.) can wait.
________________________________________
2. Sessions Collection
Purpose: Track logins, tokens, and expirations.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	userId: ObjectId (ref Users) ‚Üí link to the user.
‚Ä¢	token: String (required) ‚Üí JWT (or session ID).
‚Ä¢	authMethod: String (required) ‚Üí 'google' | 'email'.
‚Ä¢	deviceInfo: String (optional) ‚Üí browser/user-agent.
‚Ä¢	ipAddress: String (optional) ‚Üí security/audit.
‚Ä¢	expiresAt: Date (required) ‚Üí TTL for session.
‚Ä¢	createdAt: Date (default: now)
üëâ Why these fields?
‚Ä¢	Core for session management.
‚Ä¢	Minimal but secure.
‚Ä¢	TTL index on expiresAt auto-cleans old sessions.
________________________________________
3. Companies Collection (Phase 2, but keep structure ready)
Purpose: Support multi-tenant organizations.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	name: String (required)
‚Ä¢	domain: String (optional, unique)
‚Ä¢	plan: String (default: 'free') ‚Üí 'free' | 'pro' | 'enterprise'.
‚Ä¢	createdAt: Date
üëâ Why keep it lean?
‚Ä¢	For MVP, only needed if you‚Äôre targeting multi-org SaaS.
‚Ä¢	Billing/settings can come later.
________________________________________
4. Tickets Collection
Purpose: Core of Supportly ‚Äî customer requests.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	title: String (required) ‚Üí short summary.
‚Ä¢	description: String (required) ‚Üí customer‚Äôs issue.
‚Ä¢	status: String (default: 'open') ‚Üí 'open','in-progress','resolved','closed'.
‚Ä¢	priority: String (default: 'medium') ‚Üí 'low','medium','high','urgent'.
‚Ä¢	customerId: ObjectId (ref Users, required)
‚Ä¢	assignedTo: ObjectId (ref Users, optional) ‚Üí agent.
‚Ä¢	companyId: ObjectId (ref Companies, optional)
‚Ä¢	createdAt: Date (default: now)
‚Ä¢	updatedAt: Date (default: now)
üëâ Why these fields?
‚Ä¢	This is Zendesk/Jira-lite.
‚Ä¢	Status + priority enable workflow.
‚Ä¢	Minimal relationships: who raised it, who‚Äôs handling it.
________________________________________
5. Messages Collection
Purpose: Store conversations within a ticket.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	ticketId: ObjectId (ref Tickets, required)
‚Ä¢	senderId: ObjectId (ref Users, required)
‚Ä¢	content: String (required) ‚Üí message text.
‚Ä¢	isAIGenerated: Boolean (default: false) ‚Üí Gemini messages flagged.
‚Ä¢	createdAt: Date (default: now)
üëâ Why minimal?
‚Ä¢	Core chat functionality (AI + customer + agent).
‚Ä¢	Attachments, read receipts, etc. can come later.
________________________________________
6. KnowledgeBase Collection
Purpose: AI reference material.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	title: String (required)
‚Ä¢	content: String (required)
‚Ä¢	category: String (optional)
‚Ä¢	visibility: String (default: 'public') ‚Üí 'public' or 'internal'.
‚Ä¢	createdAt: Date
‚Ä¢	updatedAt: Date
üëâ Why keep it simple?
‚Ä¢	Enough for Gemini to fetch answers.
‚Ä¢	Related articles, versioning later.
________________________________________
7. Logs Collection
Purpose: Security + system monitoring.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	userId: ObjectId (optional) ‚Üí who triggered it.
‚Ä¢	action: String (required) ‚Üí e.g., 'login','ticket_created'.
‚Ä¢	details: Object (optional) ‚Üí contextual data.
‚Ä¢	severity: String (default: 'info') ‚Üí 'info','warn','error'.
‚Ä¢	timestamp: Date (default: now)
üëâ Why?
‚Ä¢	Even in MVP, logs help debug auth + tickets.
________________________________________
8. Feedback Collection
Purpose: Customer ratings for tickets.
Schema (MVP fields):
‚Ä¢	_id: ObjectId
‚Ä¢	ticketId: ObjectId (ref Tickets, required)
‚Ä¢	agentId: ObjectId (ref Users, optional)
‚Ä¢	rating: Number (1‚Äì5)
‚Ä¢	comments: String (optional)
‚Ä¢	createdAt: Date
üëâ Why?
‚Ä¢	Immediate feedback loop for support quality.
Puzzle 1 ‚Äî Project skeleton & infra sanity check
Description
Create the project skeleton and baseline infra that every other task depends on: src/ structure, index.js (or server.js), dotenv loading, Express app, MongoDB connection, ESLint/Prettier, and a simple health route.
Difficulty: Easy
Tools: Node.js, npm, Express, Mongoose, dotenv, ESLint/Prettier, nodemon (dev)
References: Official Express docs, Mongoose docs, dotenv docs
Acceptance criteria / Tests
‚Ä¢	src/index.js starts Express and returns 200 OK on GET /health with { ok: true }.
‚Ä¢	Environment variables load from .env (log them on start in non-prod for verification).
‚Ä¢	Mongoose connects to MongoDB and logs ‚Äúmongo connected‚Äù.
‚Ä¢	Project adheres to lint rules; npm run dev works.
Pitfalls / Notes
‚Ä¢	Don‚Äôt use deprecated connection options (Mongoose v6+ handles topology internally).
‚Ä¢	Keep secrets out of git; add .env to .gitignore.
Deliverables
‚Ä¢	Folder structure (config, controllers, routes, models, middleware, util).
‚Ä¢	src/index.js + src/config/db.js + .env.sample.
________________________________________


Puzzle 2 ‚Äî Users model (dual auth ready)
Description
Design and implement the User model to support both Google OAuth and email/password signups. Include fields mentioned in your refined schema (email unique, password hashed, googleId optional, authMethods, role, timestamps).
Difficulty: Medium
Tools: Mongoose, bcrypt (or bcryptjs), crypto for helper functions
Acceptance criteria / Tests
‚Ä¢	You can create a user with email/password; password is stored hashed.
‚Ä¢	You can create/find a user that has only googleId and no password.
‚Ä¢	Indexes exist for email (unique) and googleId (sparse unique).
‚Ä¢	Add unit tests: create user, match password, prevent duplicate emails.
Pitfalls / Notes
‚Ä¢	Use sparse: true for googleId index if it can be null.
‚Ä¢	Validate email format server-side and use lowercase: true for storage.
‚Ä¢	Don‚Äôt store a plain confirmPassword field in DB ‚Äî only validate at API level.
Deliverables
‚Ä¢	src/models/User.js, user creation tests, migration notes (if needed).
________________________________________
Puzzle 3 ‚Äî Local auth endpoints + JWT session issuance
Description
Implement email/password registration and login endpoints that issue a JWT (cookie + JSON). Create /auth/register, /auth/login. Add requireAuth middleware that validates JWT and attaches req.user.
Difficulty: Medium
Tools: jsonwebtoken, bcrypt, cookie-parser, express-validator (or zod) for input validation
Acceptance criteria / Tests
‚Ä¢	POST /auth/register creates user and returns JWT cookie and JSON { success: true }.
‚Ä¢	POST /auth/login verifies credentials and returns JWT cookie & JSON.
‚Ä¢	GET /auth/me (protected) returns user profile when cookie or Authorization: Bearer present.
‚Ä¢	Unit/integration tests for register/login/me flows.
Pitfalls / Notes
‚Ä¢	Keep JWT secret in .env. Use strong secret and httpOnly cookie.
‚Ä¢	Attach token to both cookie and JSON (for API clients) during dev if useful. Remove JSON token in production for safety.
‚Ä¢	Handle race conditions/duplicate email gracefully (409).
Deliverables
‚Ä¢	src/controllers/authLocalController.js, src/routes/authRoutes.js, src/middleware/authMiddleware.js.
________________________________________
Puzzle 4 ‚Äî Google OAuth flow (server-side)
Description
Implement /auth/google (redirect to Google) and /auth/google/callback (exchange code, verify id_token, create/find user, sign app JWT, set cookie). Add state CSRF protection and store refresh_token hashed.
Difficulty: Medium
Tools: google-auth-library, cookie-parser, crypto, Mongoose User model
Acceptance criteria / Tests
‚Ä¢	Visiting GET /auth/google opens consent screen and returns to frontend with ?login=success after approval.
‚Ä¢	Backend creates or updates user, stores hashed refresh token, and sets token cookie (HttpOnly).
‚Ä¢	GET /auth/me works after Google login.
Pitfalls / Notes
‚Ä¢	Ensure redirect URI in Google console exactly matches callback URL.
‚Ä¢	Use access_type=offline + prompt=consent if you need refresh tokens (store them hashed!).
‚Ä¢	Fix env typos (GOOGLE_CLIENT_SECRET vs GOOLE_...).
Deliverables
‚Ä¢	src/controllers/authController.js (googleCallback logic), updated userService to save google refresh token hashed.
________________________________________
Puzzle 5 ‚Äî Sessions & refresh token flow
Description
Implement Sessions collection and the refresh-token endpoint. Store refresh tokens hashed, support rotation: on refresh, remove old refresh token and add the new one (rotate).
Difficulty: Medium‚ÄìHard
Tools: Mongoose Sessions model, crypto (SHA256), JWT sign/verify
Acceptance criteria / Tests
‚Ä¢	POST /auth/refresh accepts a refresh token, returns new access token and new refresh token.
‚Ä¢	Old refresh token is removed (or marked invalid) after rotation.
‚Ä¢	Sessions collection entries are created with expiresAt TTL.
Pitfalls / Notes
‚Ä¢	Hash refresh tokens before storing (use SHA-256).
‚Ä¢	Don‚Äôt leak refresh tokens in responses or logs.
‚Ä¢	Consider deviceInfo to support per-device revocation.
Deliverables
‚Ä¢	src/models/Session.js, src/controllers/tokenController.js (refresh endpoint), tests for rotation & revocation.
________________________________________
Puzzle 6 ‚Äî Token blacklist & logout (server-side revocation)
Description
Implement a TokenBlacklist (or TokenRevocation) collection with TTL indexed expiresAt. Update logout endpoint to add current JWT to blacklist and clear session / cookie. Modify requireAuth middleware to consult blacklist.
Difficulty: Medium
Tools: Mongoose, TTL index
Acceptance criteria / Tests
‚Ä¢	POST /auth/logout blacklists current JWT (stores with expiry = token expiry), clears cookie.
‚Ä¢	Any subsequent requests using that JWT (even manually via Postman) fail with 401 and Token revoked.
‚Ä¢	Blacklist entries auto-delete via TTL after token expiry.
Pitfalls / Notes
‚Ä¢	Blacklist check adds a DB lookup per protected request (OK for MVP). For scale use Redis.
‚Ä¢	Ensure you decode token to get exp for TTL value.
Deliverables
‚Ä¢	src/models/TokenBlacklist.js, updated requireAuth to call isBlacklisted.
________________________________________
Puzzle 7 ‚Äî Tickets & Messages core API
Description
Implement ticket creation, assignment, and message posting endpoints. Minimal operations: create ticket, update status, post message, fetch ticket with messages (paginated).
Difficulty: Medium
Tools: Mongoose Ticket & Message models, Express routes, pagination library (or manual)
Acceptance criteria / Tests
‚Ä¢	POST /tickets creates a ticket with customerId from req.user.
‚Ä¢	GET /tickets/:id returns ticket + messages (paginated).
‚Ä¢	POST /tickets/:id/messages appends a message (customer or agent) and stores isAIGenerated: false for user messages.
‚Ä¢	PATCH /tickets/:id allows agent to change status/assign.
Pitfalls / Notes
‚Ä¢	Validate assignedTo is an agent (role) before assigning.
‚Ä¢	Use indexes ticketId + createdAt for message retrieval performance.
Deliverables
‚Ä¢	src/models/Ticket.js, src/models/Message.js, controllers and routes for tickets/messages.
________________________________________
Puzzle 8 ‚Äî Attachments (upload & metadata)
Description
Support file attachments for tickets/messages/users. MVP: accept URLs and uploads via multipart (store metadata, and optionally push files to cloud storage later).
Difficulty: Medium
Tools: multer (for multipart), cloud storage SDK (later), Mongoose Attachment model
Acceptance criteria / Tests
‚Ä¢	POST /tickets/:id/attachments accepts either a URL or file upload, returns attachment metadata (fileUrl, fileType, uploadedBy).
‚Ä¢	Attachments are linked to ticketId or messageId via relatedTo & relatedModel.
‚Ä¢	Retrieval endpoint GET /attachments/:id returns metadata (files served via cloud/public URL).
Pitfalls / Notes
‚Ä¢	Don‚Äôt store large base64 blobs in DB. Store files in S3/GCS and keep URLs in DB.
‚Ä¢	Validate file types and size limits to prevent abuse. Scan files if needed (virus scanning later).
Deliverables
‚Ä¢	src/models/Attachment.js, multipart upload route, URL ingestion logic.
________________________________________
Puzzle 9 ‚Äî Gemini integration (text + image flows)
Description
Wire Gemini endpoints to generate AI responses for tickets. Two endpoints: /ai/text (prompt + context), /ai/image (prompt + image handling). Store raw AI output in Message.rawResponse and create Message with isAIGenerated:true.
Difficulty: Medium‚ÄìHard
Tools: @google/genai (or appropriate SDK), base64 conversion for remote images, controllers, Message model
Acceptance criteria / Tests
‚Ä¢	POST /ai/text returns an AI response and stores it as a message in the correct ticket.
‚Ä¢	POST /ai/image accepts an image URL, fetches and base64-encodes it if required, sends to Gemini, stores response.
‚Ä¢	Responses include provenance: model name, request/response ids in rawResponse.
Pitfalls / Notes
‚Ä¢	Images must be passed as base64 if SDK expects bytes ‚Äî fetch and convert server-side.
‚Ä¢	Watch for token errors and model availability (use correct model names). Rate-limit AI calls to avoid surprise bills.
Deliverables
‚Ä¢	src/controllers/aiController.js, endpoints wired into ticket flows, tests in Postman.
________________________________________
Puzzle 10 ‚Äî Security & hardening (rate limits, CORS, helmet)
Description
Add middleware: CORS, Helmet, rate limiting on public/AI endpoints, input validation, and sanitize user inputs.
Difficulty: Easy‚ÄìMedium
Tools: helmet, express-rate-limit, cors, express-validator / zod
Acceptance criteria / Tests
‚Ä¢	GET /health still works; AI endpoints limited (e.g., 10 requests/min per IP).
‚Ä¢	Input payloads validated and rejected with 400 if malformed.
‚Ä¢	CORS only allows frontend origin(s) in production.
Pitfalls / Notes
‚Ä¢	Dev vs Prod config for CORS and rate limits.
‚Ä¢	Keep rate limits adjustable via env.
Deliverables
‚Ä¢	src/middleware/rateLimiter.js, validation middleware, updated index.js.
________________________________________
Puzzle 11 ‚Äî Logging & centralized error handling
Description
Integrate request logging (morgan / winston), structured error handler middleware, and persistent audit logging collection for important events.
Difficulty: Easy‚ÄìMedium
Tools: morgan, winston, Mongoose AuditLog model
Acceptance criteria / Tests
‚Ä¢	All requests logged to console during dev; critical errors logged to a file or external service.
‚Ä¢	Error responses are standardized: { success:false, error: "message" }.
‚Ä¢	Important events (login, logout, ticket create) write an audit log entry.
Pitfalls / Notes
‚Ä¢	Don‚Äôt log secrets (API keys, tokens). Redact where necessary.
‚Ä¢	Use different transports for production (e.g., Cloud Logging).
Deliverables
‚Ä¢	src/util/logger.js, src/middleware/errorHandler.js, src/models/AuditLog.js.
________________________________________
Puzzle 12 ‚Äî Tests, Postman collection, and CI
Description
Add unit tests for core models/controllers and a Postman collection to demonstrate end-to-end flows. Wire a basic CI (GitHub Actions) to run tests on push.
Difficulty: Medium‚ÄìHard
Tools: Jest, supertest, mongodb-memory-server, Postman, GitHub Actions
Acceptance criteria / Tests
‚Ä¢	Unit tests pass locally and in CI.
‚Ä¢	Postman collection covers: register/login, Google login (manual step), create ticket, post message, AI call, logout.
‚Ä¢	CI runs unit tests on push and fails on test errors.
Pitfalls / Notes
‚Ä¢	Mock external calls (Gemini, Google OAuth) in unit tests; use integration tests sparingly with real providers.
‚Ä¢	Use in-memory MongoDB for CI to avoid DB flakiness.
Deliverables
‚Ä¢	tests/ folder, Postman collection JSON, .github/workflows/test.yml.
________________________________________
Final Checklist & Suggested order to execute (priority)
1.	Puzzle 1 ‚Äî skeleton & DB connect (required)
2.	Puzzle 2 ‚Äî User model (foundation)
3.	Puzzle 3 ‚Äî Local auth + JWT + /me (essential)
4.	Puzzle 4 ‚Äî Google OAuth (integrate sign-in)
5.	Puzzle 6 ‚Äî Blacklist & logout (security)
6.	Puzzle 5 ‚Äî Sessions & refresh (rotating refresh tokens)
7.	Puzzle 7 ‚Äî Tickets & Messages (core app behavior)
8.	Puzzle 8 ‚Äî Attachments (files)
9.	Puzzle 9 ‚Äî Gemini integration (AI features)
10.	Puzzle 10 ‚Äî Security hardening (rate-limits, helmet)
11.	Puzzle 11 ‚Äî Logging / error handling / audit logs
12.	Puzzle 12 ‚Äî Tests & CI
(you can do 6 before 5 if you prefer immediate logout behavior; order is flexible)
________________________________________
Quick testing recipes (how to verify progress)
‚Ä¢	After P1‚ÄìP3: POST /auth/register, POST /auth/login, GET /auth/me in Postman.
‚Ä¢	After P4: Browser -> /auth/google -> confirm cookie set -> GET /auth/me.
‚Ä¢	After P6: Login -> copy cookie -> POST /auth/logout -> GET /auth/me should fail.
‚Ä¢	After P7‚ÄìP9: Walk through Postman script: create ticket -> post message -> call /ai/text -> confirm AI message saved.
‚Ä¢	After P8: Upload sample screenshot -> confirm attachment metadata and link present on ticket.
________________________________________
Final notes & best practices (engineer-to-engineer)
‚Ä¢	Keep secrets in environment/config stores (don‚Äôt commit). Use Vault/Secrets Manager when deploying.
‚Ä¢	Use migrations or a schema registry if you alter models later.
‚Ä¢	For performance-sensitive parts (blacklist checks, rate-limits, embeddings), move to Redis later.
‚Ä¢	Log structured events (JSON) for easy analysis.
‚Ä¢	Prepare a small Postman README so a client or reviewer can run the full flow manually.

